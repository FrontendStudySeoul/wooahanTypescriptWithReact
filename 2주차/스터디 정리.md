## 데스티네이션 코드 타입
- 함수를 직접 사용자가 결괏값 타이핑에 es를 사용함으로써 사용자 정의 타입 카드를 만든다는 것을 볼 수 있음
- 데스티네이션 코드를 작성한 거를 예시에서 그대로 사용을 하면 STR이 들어오면서 데스티네이션 코드를 실행시킴
- 트루 값을 나타내면 데스티네이션 코드 타입이랑 타입에 있는 STR이 TR이 데스티네이션 코드 타입이다라는 것을 알 수 있음
- 데스티네이션 코드 타입을 식별할 수 있는 유니온 까이라는 게 나옴
- 식별할 수 있는 타입을 어떻게 선정을 하냐 하면 리터럴 타입이어야 함
- 적어도 하나 이상의 유닛 타입이 포함되어야 하고 인스턴스화할 수 없는 타입은 포함되지 않아야 함

## TS 패턴의 장점
- 패턴 매칭을 구현할 수 있게 해주는 라이브러리인 TS 패턴을 사용하면 코드가 선언적이고 깔끔해지는 걸 볼 수 있음
- TS 패턴을 사용할 수 있는 자료 구조는 모든 자료 구조가 다 가능함
- TS 패턴을 사용하면 타입과 런타임, 컴파일 둘 다 강화를 시켜버림

## 식별할 수 있는 유니온
- 식별할 수 있는 유니온을 사용해서 프로스 추론을 할 수 있음
- 식별할 수 있는 유니온을 사용해서 프롭스를 좀 더 예쁘게 만들 수 있음
- 복잡한 디자인 시스템을 만들 때는 식별할 수 있는 유니온을 사용하면 사용자가 편함

## 옵셔널 타입의 지향
- 옵셔널 타입을 지향해야 되는 건지 말아야 되는 건지 고민이 있음
- 옵셔널이 많으면 많을수록 인터페이스나 타입에 대한 타입이 약해지니까 옵셔널을 지향하는 바가 아님
- 옵셔널을 써야 되는 상황은 데이터를 가지고 있어야 되는 상황일 때임

## 조건부 타입의 활용
- 조건부 타입은 타입스크립트에서 조건에 따라서 달인 타입을 반환해야 되는 경우들이 있음
- 조건부 타입을 사용해서 출력 타입을 다르게 도출할 수 있음
- 조건부 타입을 활용하게 되면 중복되는 타입을 제거할 수 있고 상황에 따라서 적절한 타입을 얻을 수 있어서 더 정확한 타입을 추론할 수 있음

## 제네릭 타입의 추론
- 타입을 추론해 줌으로써 더 간편하게 타입을 작성할 수 있음
- 제네릭으로 받은 라우트 타입을 추론해서 아이템이라는 추론한 값이 라우터 아이템이라면 children이 있는지를 확인하고 children 타입을 추론함
- children이 있다면 함수를 통해 재기적으로 다시 돌아가서 children을 넘겨줘서 다시 한 번 돌게 됨

## 제네릭 타입의 활용
- 제네릭 사용할 때 T,K,P 이렇게 작성하는데 좋지 못한 방향임
- 제네릭 사용하는 측면에서 타입을 보는 사람 입장에서 더 좋은 방법일 수 있음

## 타입 검사의 오류
- 타입스크립트에서는 서로 다른 두 개 이상의 객체를 유니온 타입으로 받을 때 타입 검사가 제대로 진행되지 않는 이슈가 있음
- 카드랑 어카운트라는 타입이 있고 이거를 받는 함수 인자가 있다고 했을 때 이런 식으로 작성하게 되면 카드가 될 수 있고 어카운트가 될 수 둘 다 들어갈 수 있기 때문에 타입 에러가 발생함
- 타입의 집합 관점으로 봤을 때 작성한 이 객체가 합집합의 범주에 들어가기 때문에 타입 에러가 발생하지 않음
- 이런 문제 상황을 식별할 수 있는 부분을 사용해서 해결을 했다고 함

## 타입 스크립트의 타입 검사
- 논널럽한 타입 검사를 하는 함수가 소개가 되는데 타입을 만들어서 널이나 언디파인드가 아닐 때 리턴하는 식으로 함수를 만들어줌
- 타입 가드인 함수를 만들어서 타입적으로 보완이 되게 만들어줌
- 불변 객체 타입으로 활용하기인데 너무 간단하고 예제만 쓸데없이 길어서 축약함
- 리코드 원시 타이키 개선하기인데 객체 선언 시 키가 어떤 값인지 명확하지 않다면 리코드의 키를 스트링이나 넘버로 넣게 됨
- 타입스크립트는 키가 유효하지 않더라도 타입상으로 문제가 없기 때문에 오류를 표시하지 않음
- 유니온타입으로 변경해서 해결할 수 있는데 무한한 경우에는 이런 방식을 사용하라고 함
