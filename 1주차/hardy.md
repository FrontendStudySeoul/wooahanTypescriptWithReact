## 웹 개발의 역사

### 자바스크립트의 탄생

- 1995년 넷스케이프의 브래든 아이크가 웹의 다양한 컨텐츠를 표현하고자 자바스크립트를 만들었다.

### ECMAScript의 탄생

- 경쟁 관계던 넷스케이프와 마이크로소프트는 브라우저의 새로운 기능을 추가하지만 추가된 기능은 각자의 브라우저에서만 동작해 크로스 브라우징 이슈가 발생한다.
- 자바스크립트는 브라우저 생태계를 고려해 만든 언어가 아니였고 브라우저 발전 속도를 따라갈 수 없었다.
- 모든 브라우저에서 동일하게 동작하는 표준화된 자바스크립트의 필요해 표준을 관리하는 Ecma 인터내셔널에 자바스크립트의 표준화를 위한 기술 규격을 제출, EMAScript라는 표준화를 공식화 했다.

### 웹사이트에서 웹 애플리케이션의 전환

- 웹의 성장함에 따라 단순히 보여주는 역할에서 상호 작용하는 웹 애플리케이션이 등장함.
- 웹사이트와 웹 애플리케이션 차이는 동적인지 아닌지의 차이

### 개발 생태계 발전

- Ajax로 비동기 요청을 사용해서 페이지의 일부 데이터를 로드할 수 있게 됨
- 컴포넌트 베이스 개발 방법론이 등장
- 생태계의 발전과 거대한 동적 웹 서비스의 수요 증가는 자바스크립트 개발자의 증가로 이어짐

## 자바스크립트의 한계

### 동적 타입 언어

- 자바스크립트의 특징 중 하나는 동적 타입 언어다.
- 런타임에 변수값이 할당될 때 해당 값의 타입에 따라 변수 타입이 결정된다는 것을 의미한다.

### 동적 타이핑 시스템의 한계

```jsx
const sumNumber = (a,b) => {
  return a + b 
}

sumNumber(1, 2) // 3
sumNumber(100) // NaN
sumNumber("a","b") // ab
```

- 자바스크립트는 동적 타입 언어이자 상당히 관대한 언어이기 때문에 함수를 호출할 때 사용되는 인수 값에 따라 a와 b의 타입이 결정되어 위 코드 같은 문제가 발생

### 한계 극복을 위한 해결 방안

- 동적 타이핑 시스템의 한계는 협업을 어렵게 만든다.
- 따라서 개발자들은 자바스크립트의 인터페이스의 필요성을 느끼게 되고 아래와 같은 해결 방안들이 등장했다

**JSDoc**

주석으로 타입 힌트를 제공할 수 있다.

**propTypes**

리액트 컴포넌트 props의 타입을 검사하기 위해 사용하는 리액트 속성

**다트**

구글이 자바스크립트를 대체하기 위해 제시한 새로운 언어

### 타입스크립트의 등장

- 마이크로소프트에서 자바스크립트의 슈퍼셋 언어인 타입스크립트를 공개
- 다트와 달리 자바스크립트 코드를 그대로 사용할 수 있고 아래와 같은 단점을 극복

**안정성 보장**

타입스크립트는 정적 타이핑을 제공, 컴파일 단계에서 타입 검사를 해줘 사전에 에러를 방지할 수 있다.

**개발 생산성 향상**

타입 자동 완성 기능을 제공

**협업에 유리**

타입이 기술되면 코드를 더 쉽게 이해할 수 있게 도와줘 협업에 유리하다.

**자바스크립트에 점진적으로 적용 가능**

타입스크립트는 자바스크립트의 슈퍼셋이기 때문에 점진적인 도입이 가능

## 타입이란

### 자료형으로서의 타입

- 자바스크립트는 7가지 데이터 타입(자료형)을 정의한다.
    - undefined
    - null
    - Boolean
    - String
    - Symbol
    - Numeric
    - Object

### 집합으로서의 타입

- 타입은 수학의 집합과 유사하다. 타입은 값이 가질 수 있는 유효한 범위의 집합을 말한다.
- number 타입의 경우 number 타입 값만 할당할 수 있다. 집합의 속하지 않는 string 타입을 할당할 경우 에러가 발생한다.

### 정적 타입과 동적 타입

- 타입을 결정하는 시점에 따라 타입을 정적 타입, 동적 타입으로 분류할 수 있다.

### 강타입과 약타입

- 강타입은 서로 다른 타입을 갖는 값끼리 연산을 시도하면 컴파일러에서 에러가 발생한다.
- 약타입은 연산할 때 컴파일러가 내부적으로 판단해 특정 값의 타입을 변환하여 연산을 수행한 두 값을 도출한다.

### 컴파일 방식

- 컴파일은 사람이 이해할 수 있는 방식으로 작성한 코드를 컴퓨터가 이해할 수 있는 기계어로 변환하는 과정을 말한다.
- 하지만 타입스크립트의 컴파일 결과물은 여전히 사람이 이해할 수 있는 자바스크립트 파일이다. 타입스크립트의 탄생 이유가 자바스크립트의 컴파일타임에 런타임 에러를 사전에 잡아내기 위한 것이다.

## 타입 시스템

### 타입 애너테이션 방식

- 타입애너테이션이란 변수나 상수 혹은 함수의 인자와 반환 값에 타입을 명시적으로 선언해서 어떤 타입 값이 저장될 것인지를 컴파일러에 직접 알려주는 문법이다.
- 타입스크립트의 타입 선언 방식은 변수 이름 뒤에 `: type` 구문을 붙여 데이터 타입을 명시한다.

### 구조적 타이핑

```jsx
interface Developer {
  faceValue: number;
}

interface BankNote {
  faceValue: number;
}

let developer: Developer = { faceValue: 52 };
let bankNote: BankNote = { faceValue: 10000 };

developer = bankNote; // OK
bankNote = developer; // OK
```

- 타입스크립트는 구조로 타입을 구분한다. 이것을 구조적 타이핑이라고 한다.

### 구조적 서브타이핑

- 구조적 서브타이핑이란 객체가 가지고 있는 속성을 바탕으로 타입을 구분하는 것이다. 이름이 다른 객체라도 가진 속성이 동일하다면 타입스크립트는 서로 호환이 가능한 동일한 타입으로 여긴다.

```jsx
interface Pet {
  name: string;
}

interface Cat {
  name: string;
  age: number;
}

let pet: Pet;
let cat: Cat = { name: "Zag", age: 2 };

pet = cat; // OK
```

### 자바스크립트를 닮은 타입스크립트

- 자바스크립트는 덕 타이핑을 기반으로 한다.
    - 덕 타이핑은 어떤 타입에 부합하는 변수와 메서드를 가질 경우 해당 타입에 속하는 것으로 간주하는 방식이다.
- 타입스크립트가 구조적 타이핑을 채택한 이유는 자바스크립트를 모델링한 언어이기 때문이다.

**덕 타이핑**

- 런타임에 타입을 검사한다.
- 주로 동적 타이핑에서 사용된다.

**구조적 타이핑**

- 컴파일 타임에 타입체커가 타입을 검사한다.
- 정적 타이핑에서 사용된다.

### 구조적 타이핑의 결과

```
interface Cube {
  width: number;
  height: number;
  depth: number;
}

function addLines(c: Cube) {
  let total = 0;

  for (const axis of Object.keys(c)) {
    // Element implicitly has an 'any' type
    // because expression of type 'string' can't be used to index type 'Cube'.
    // No index signature with a parameter of type 'string'
    // was found on type 'Cube'
    const length = c[axis];

    total += length;
  }
}
```

- `Cube` 인터페이스의 모든 필드는 `number` 타입을 가지지만, `c`에 들어올 객체는 `Cube`의 `width`, `height`, `depth` 외에도 어떤 속성이든 가질 수 있기 때문에 `c[axis]`의 타입이 `string`일 수도 있어 에러가 발생한다. 즉, 아래와 같은 상황이다.

```
const namedCube = {
  width: 6,
  height: 5,
  depth: 4,
  name: "SweetCube", // 추가
};

addLines(namedCube); // OK
```

- 타입스크립트는 `c[axis]`가 어떤 속성을 지닐지 알 수 없으며 `number`라고 확정할 수 없어서 에러를 발생시킨다.

### 타입스크립트의 점진적 타입 확인

- 점진적 타입 검사란 컴파일 타임에 타입을 검사하면서 필요에 따라 타입 선언 생략을 허용하는 방식이다.
- 타입을 지정한 변수와 표현식은 정적으로 타입을 검사하지만 타입 선언이 생략되면 동적으로 검사를 수행한다.

```
function add(x, y) {
  return x + y;
}

// 암시적 타입 변환
function add(x: any, y: any): any;
```

- 타입 선언을 생략하면 암시적 타입 변환이 일어난다.

### 자바스크립트 슈퍼셋으로서의 타입스크립트

- 타입스크립트는 자바스크립트의 상위 집합이다. 타입스크립트 문법은 모든 자바스크립트 문법을 포함하고 있다.

### 값 vs 타입

- 프로그래밍 관점에서는 문자열,숫자,변수,매개변수 등이 값에 해당한다.
- 객체도 값, 자바스크립트에서는 함수도 값이다.
- 타입스크립트를 사용하게 되며 타입이라는 개념이 등장한다. `: type` 형태로 타입을 명시한다.
- 또는 type이나 interface 키워드로 커스텀 타입을 정의할 수도 있다.
- 값 공간과 타입 공간의 이름은 서로 충돌하지 않기 때문에 타입과 변수를 같은 이름으로 정의할 수 있다. 이는 타입스크립트가 자바스크립트의 슈퍼셋인 것과 관련 있다.

```
type Developer = { isWorking: true };
const Developer = { isTyping: true }; // OK

type Cat = { name: string; age: number };
const Cat = { slideStuffOffTheTable: true }; // OK
```

- 타입스크립트에서 값과 타입의 구분은 맥락에 따라 달라지기 때문에 값 공간과 타입 공간을 혼동할 때도 있다.

```
function email(options: { person: Person; subject: string; body: string }) {
 ...
}

// 자바스크립트의 구조 분해 할당으로 풀어 쓸 수 있다.
function email({ person, subject, body }) {
 ...
}

// 타입은 구조 분해 할당할 수 없다.
function email({
  person: Person, // Error
  subject: string, // Error
  body: string, // Error
}) {
 ...
}
```

- 값의 관점에서 Person가 string이 해석되었기 때문에 오류가 발생한다.
- 값과 타입 공산에 동시에 존재하는 심볼도 있다. 대표적으로 클래스와 enum이다.

```
class Rectangle {
  constructor(height, width) {
    this.height = height;
    this.width = width;
  }
}

const rect1 = new Rectangle(5, 4);
```

- 클래스는 객체 인스턴스를 쉽게 생성하기 위한 문법 기능으로 동작은 함수와 같다. 동시에 타입으로도 사용된다.

```
enum Direction {
  Up, // 0
  Down, // 1
  Left, // 2
  Right, // 3
}
```

- enum은 런타임에 객체로 변환되는 값이다. 런타임에 실제 객체로 존재하며, 함수로 표현할 수도 있다.
